#include <iostream>
using namespace std;

//*의 의미 : 1. 바구니 라고 명시, 2. 넘겨준 주소로 넘어가라

void SetHp(int* hp) {
	*hp = 100;
}
int main() {

	int hp = 1;
	SetHp(&hp);

	//지금까지 사용한 방식
	// number 라는 이름의 4바이트 정수 타입의 바구니를 만든다.
	// number 라는 변수 스택 메모리에 할당
	// number = 1라 함은, number 바구니에 1이라는 숫자를 넣으라는 의미이다.
	// 따라서 스택 메모리에 있는 특정 주소(number 바구니)에 우리가 원하는 값을 넣은 셈
	// number는 비유하자면 메모리에 이름을 붙인 것 (찰떡 같이 알아들어서 변환해 주는것)
	// 나쁘지 않고 편리한데 단점은 원본 수정이 힘들다.

	//int number = 1;


	// TYPE* 변수이름
	// TYPE
	// *


	// 포인터 = 주소를 저장하는 바구니
	// 변수를 선언할 때 *이 등장했다. -> 포인터 = 주소
	//int* ptr;

	// 메모리의 주소를 알아야지만 값의 변경이나 읽는 것이 가능
	// 

	// &의 주소를 꺼내서 ptr에 대입해주세요
	// 포인터는 32비트 os일시 4바이트, 64비트일스 8바이트 고정이다.
	// 스택에 있는 ptr이라는 바구니에 number의 주소를 넣어줘
	//int* ptr = &number;

	//이 주소가지고 뭘 하라는거임?
	//이 주소에 접근해서 해당 내용을 빼오거나 주소에 접근해서 내용물을 바꾸는 기능이 존재함
	//추가문법이 필요 : [주소를 저장하는 바구니]가 가르키는 주소로 가서 무엇인가를 해라!

	//ptr이라는 바구니가 가르키는 해당 주소를 가져오는 것
	int value1 = *ptr;
	*ptr = 2;
	//cout << number;



	// 포인터 기초#2
	// * = 포인터의 의미 = 주소를 저장하는 바구니 4/8바이트 고정 크기
	// 이점은 *가 존재하면 4/8바이트 라는점(int)없어도 된다.
	// 그런데 왜 굳이 int를 적음? 안적으면 문법적 오류도남
	
	//주소에 가면 뭐가 있는지 알려주기 위함
	// * = 포인터 (주소 담는 바구니)
	// Type을 적어주는 이유는 주소를 찾아 갔을때 어떤 Type의 데이터가 있는지 알려주기 위함
	
	//타입이 불일치 할 경우? ()로 강제 통과
	//문제가 없을 수도 있지만 다른 중요한 데이터가 저장돼있는 주소를 해칠 수 있음
	
	//__int64* ptr2 = (__int64*)&number;

	*ptr2 = 0xAABBCCDDEEFF;
	// 포인터를 이용해서 주소를 잘못 입력했을시 해당 주소를 넘어서 사용하게 되면 데이터를 덮어 쓸 수 있는 문제가 발생 할 수 있다.



	//  오늘의 주제 : 포인터 연산
	//1) 주소 연산자 (&)
	//2) 산술 연산자
	//3) 간접 연산자
	//4) 간접 멤버 연산자

	int number = 1;



	//1) 주소 연산자를 이용해서 주소를 뽑아올 수 있었다.
	// 해당 변수의 주소를 알려주세요~

	//number라는 변수의 주소가 pointer에 들어간다.
	//더 정확히 말하면 해당 변수 타입(Type)에 따라서 Type*를 반환한다.
	int* pointer = &number;



	//2) 산술 연산자 (+ - 내용)
	//number = number + 1;
	number++;
	//++number;
	//number += number;
	// 이런 문법들이 포인터에도 가능하다.

	//pointer += 1;
	pointer++;

	cout << number;
	cout << pointer;





	return 0;


}